"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applySession = void 0;
const cookie_1 = require("cookie");
const nanoid_1 = require("nanoid");
const memory_1 = __importDefault(require("./store/memory"));
const stringify = (sess) => JSON.stringify(sess, (key, val) => (key === 'cookie' ? undefined : val));
const commitHead = (res, name, session, touched, encodeFn) => {
    if (res.headersSent || !session)
        return;
    if (session.isNew || touched) {
        const cookieArr = [
            cookie_1.serialize(name, encodeFn ? encodeFn(session.id) : session.id, {
                path: session.cookie.path,
                httpOnly: session.cookie.httpOnly,
                expires: session.cookie.expires,
                domain: session.cookie.domain,
                sameSite: session.cookie.sameSite,
                secure: session.cookie.secure,
            }),
        ];
        const prevCookies = res.getHeader('set-cookie');
        if (prevCookies) {
            if (Array.isArray(prevCookies))
                cookieArr.push(...prevCookies);
            else
                cookieArr.push(prevCookies);
        }
        res.setHeader('set-cookie', cookieArr);
    }
};
const prepareSession = (session) => {
    const obj = {};
    for (const key in session)
        !(key === ('isNew' || key === 'id')) && (obj[key] = session[key]);
    return obj;
};
const save = async (store, session) => session && store.__set(session.id, prepareSession(session));
function setupStore(store) {
    if ('__normalized' in store)
        return store;
    const s = store;
    s.__destroy = function destroy(sid) {
        return new Promise((resolve, reject) => {
            const done = (err) => (err ? reject(err) : resolve());
            const result = this.destroy(sid, done);
            if (result && typeof result.then === 'function')
                result.then(resolve, reject);
        });
    };
    s.__get = function get(sid) {
        return new Promise((resolve, reject) => {
            const done = (err, val) => err ? reject(err) : resolve(val);
            // @ts-ignore: Certain differences between express-session type and ours
            const result = this.get(sid, done);
            if (result && typeof result.then === 'function')
                result.then(resolve, reject);
        });
    };
    s.__set = function set(sid, sess) {
        return new Promise((resolve, reject) => {
            const done = (err) => (err ? reject(err) : resolve());
            // @ts-ignore: Certain differences between express-session type and ours
            const result = this.set(sid, sess, done);
            if (result && typeof result.then === 'function')
                result.then(resolve, reject);
        });
    };
    if (store.touch) {
        s.__touch = function touch(sid, sess) {
            return new Promise((resolve, reject) => {
                const done = (err) => (err ? reject(err) : resolve());
                // @ts-ignore: Certain differences between express-session type and ours
                const result = this.touch(sid, sess, done);
                if (result && typeof result.then === 'function')
                    result.then(resolve, reject);
            });
        };
    }
    s.__normalized = true;
    return s;
}
let memoryStore;
async function applySession(req, res, options = {}) {
    var _a, _b, _c, _d, _e, _f;
    if (req.session)
        return;
    // This allows both promised-based and callback-based store to work
    const store = setupStore(options.store || (memoryStore = memoryStore || new memory_1.default()));
    // compat: if rolling is `true`, user might have wanted to touch every time
    // thus defaulting options.touchAfter to 0 instead of -1
    if (options.rolling && !('touchAfter' in options)) {
        console.warn('The use of options.rolling is deprecated. Setting this to `true` without options.touchAfter causes options.touchAfter to be defaulted to `0` (always)');
        options.touchAfter = 0;
    }
    const name = options.name || 'sid';
    const commit = async () => {
        commitHead(res, name, req.session, shouldTouch, options.encode);
        await save(store, req.session);
    };
    const destroy = async () => {
        await store.__destroy(req.session.id);
        req.session = null;
    };
    let sessId = req.headers && req.headers.cookie ? cookie_1.parse(req.headers.cookie)[name] : null;
    if (sessId && options.decode)
        sessId = options.decode(sessId);
    // @ts-ignore: req.session as this point is not of type Session
    // but SessionData, but the missing keys will be added later
    req.session = sessId ? await store.__get(sessId) : null;
    if (req.session) {
        req.session.commit = commit;
        req.session.destroy = destroy;
        req.session.isNew = false;
        req.session.id = sessId;
        // Some store return cookie.expires as string, convert it to Date
        if (typeof req.session.cookie.expires === 'string')
            req.session.cookie.expires = new Date(req.session.cookie.expires);
    }
    else {
        req.session = {
            cookie: {
                path: ((_a = options.cookie) === null || _a === void 0 ? void 0 : _a.path) || '/',
                httpOnly: ((_b = options.cookie) === null || _b === void 0 ? void 0 : _b.httpOnly) || true,
                domain: ((_c = options.cookie) === null || _c === void 0 ? void 0 : _c.domain) || undefined,
                sameSite: (_d = options.cookie) === null || _d === void 0 ? void 0 : _d.sameSite,
                secure: ((_e = options.cookie) === null || _e === void 0 ? void 0 : _e.secure) || false,
                ...(((_f = options.cookie) === null || _f === void 0 ? void 0 : _f.maxAge) ? { maxAge: options.cookie.maxAge, expires: new Date() }
                    : { maxAge: null }),
            },
            commit,
            destroy,
            isNew: true,
            id: (options.genid || nanoid_1.nanoid)(),
        };
    }
    // prevSessStr is used to compare the session later
    // for touchability -- that is, we only touch the
    // session if it has changed. This check is used
    // in autoCommit mode only
    const prevSessStr = options.autoCommit !== false
        ? req.session.isNew
            ? '{}'
            : stringify(req.session)
        : undefined;
    let shouldTouch = false;
    if (req.session.cookie.maxAge) {
        if (
        // Extend expires either if it is a new session
        req.session.isNew ||
            // or if touchAfter condition is satsified
            (typeof options.touchAfter === 'number' &&
                options.touchAfter !== -1 &&
                (shouldTouch =
                    req.session.cookie.maxAge * 1000 -
                        (req.session.cookie.expires.getTime() - Date.now()) >=
                        options.touchAfter))) {
            req.session.cookie.expires = new Date(Date.now() + req.session.cookie.maxAge * 1000);
        }
    }
    // autocommit: We commit the header and save the session automatically
    // by "proxying" res.writeHead and res.end methods. After committing, we
    // call the original res.writeHead and res.end.
    if (options.autoCommit !== false) {
        const oldWritehead = res.writeHead;
        res.writeHead = function resWriteHeadProxy(...args) {
            commitHead(res, name, req.session, shouldTouch, options.encode);
            return oldWritehead.apply(this, args);
        };
        const oldEnd = res.end;
        res.end = async function resEndProxy(...args) {
            if (stringify(req.session) !== prevSessStr) {
                await save(store, req.session);
            }
            else if (req.session && shouldTouch && store.__touch) {
                await store.__touch(req.session.id, prepareSession(req.session));
            }
            oldEnd.apply(this, args);
        };
    }
    // Compat
    req.sessionStore = store;
}
exports.applySession = applySession;
